/* Autogenerated by sand_branch_apply_v2.sh */
#include "Experience_Sand.h"
#include "AccelSensor.h"
#include "TOF.h"
#include <Arduino.h>
#include <math.h>

#ifndef BLACK
#define BLACK 0x0000
#endif
#ifndef WHITE
#define WHITE 0xFFFF
#endif

extern Arduino_GFX *gfx;
extern AccelSensor accel;
extern TOF tof;

Experience_Sand::Experience_Sand()
: count_(0),
  zoneCount_(0),
  phaseStartMs_(0),
  lastFrameMs_(0),
  lastFpsStampMs_(0),
  framesThisSec_(0),
  fps_(0),
  phase_(PH_SETUP)
{
  for (uint16_t i=0;i<MAX_PARTICLES;++i) live_[i]=0;
  for (uint8_t z=0; z<MAX_ZONES; ++z) zones_[z] = {120,120, 0, false, 0};
}

void Experience_Sand::setup() 
{
  setExperienceName( sandname );

  phase_ = PH_SETUP;
  phaseStartMs_ = millis();
  lastFrameMs_  = phaseStartMs_;
  lastFpsStampMs_ = phaseStartMs_;
  framesThisSec_ = 0; fps_ = 0;
  clearScreen();

  seedRandomGrains(SETUP_PARTICLES);
  for (uint16_t i=0, seeded=0; i<MAX_PARTICLES && seeded<SETUP_PARTICLES; ++i) if (live_[i]) {
    seedRandomVelocity(i, 6);
    ++seeded;
  }
}

void Experience_Sand::run() {
  if (phase_ == PH_DONE) return;

  unsigned long now = millis();
  uint32_t dtMs = (now > lastFrameMs_) ? (now - lastFrameMs_) : 16;
  if (dtMs > 33) dtMs = 33;
  lastFrameMs_ = now;

  int16_t gxQ88=0, gyQ88=16;
  readTiltQ88(gxQ88, gyQ88);

  switch (phase_) {
    case PH_SETUP:
      stepSetup(dtMs, gxQ88, gyQ88);
      if (now - phaseStartMs_ > 1200) { phase_ = PH_RUN; phaseStartMs_ = now; }
      break;
    case PH_RUN:
      stepRun(dtMs, gxQ88, gyQ88);
      break;
    case PH_TEARDOWN:
      stepTeardown(dtMs);
      if (now - phaseStartMs_ > TEARDOWN_MS) { phase_ = PH_DONE; }
      break;
    default: break;
  }

  endFrame();
}

void Experience_Sand::teardown() {
  if (phase_ == PH_DONE) return;
  phase_ = PH_TEARDOWN;
  phaseStartMs_ = millis();
}

void Experience_Sand::beginFrame() {}
void Experience_Sand::endFrame() {
  ++framesThisSec_;
  unsigned long now = millis();
  if (now - lastFpsStampMs_ >= 1000) {
    fps_ = framesThisSec_;
    framesThisSec_ = 0;
    lastFpsStampMs_ = now;
  }
}

void Experience_Sand::clearScreen() { if (gfx) gfx->fillScreen(BLACK); }
inline void Experience_Sand::erasePixel(uint16_t px, uint16_t py) { if (gfx) gfx->drawPixel(px, py, BLACK); }
inline void Experience_Sand::drawPixel(uint16_t px, uint16_t py) { if (gfx) gfx->drawPixel(px, py, WHITE); }

void Experience_Sand::seedRandomGrains(uint16_t n) {
  uint16_t placed = 0; uint16_t guard = 0;
  while (placed < n && guard < n*10) {
    ++guard;
    int idx = findFree();
    if (idx < 0) break;
    uint16_t px = (uint16_t)random(0, W);
    uint16_t py = (uint16_t)random(0, H);
    x_[idx]=px; y_[idx]=py;
    vx_[idx]=0; vy_[idx]=32;
    live_[idx]=1; ++count_;
    drawPixel(px,py);
    ++placed;
  }
}

void Experience_Sand::seedRandomVelocity(uint16_t i, int8_t magQ88) {
  int8_t rx = (int8_t)random(-magQ88, magQ88+1);
  int8_t ry = (int8_t)random(-magQ88, magQ88+1);
  vx_[i] = rx; vy_[i] = ry;
}

void Experience_Sand::readTiltQ88(int16_t &gxQ88, int16_t &gyQ88) {
  float ax = accel.getXreading();
  float ay = accel.getYreading();
  gxQ88 = (int16_t)(ax * 256.0f);
  gyQ88 = (int16_t)(ay * 256.0f);
}

void Experience_Sand::stepSetup(uint32_t dtMs, int16_t gxQ88, int16_t gyQ88) {
  beginFrame();
  for (uint16_t i=0;i<MAX_PARTICLES;++i) if (live_[i]) {
    erasePixel(x_[i], y_[i]);
    applyOne(i, gxQ88/2, gyQ88 + 24);
    integrate(i, dtMs);
    drawPixel(x_[i], y_[i]);
  }
}

void Experience_Sand::stepRun(uint32_t dtMs, int16_t gxQ88, int16_t gyQ88) {
  beginFrame();
  updateZonesFromTOF();
  expireStaleZones(millis());

  for (uint16_t i=0;i<MAX_PARTICLES;++i) if (live_[i]) {
    erasePixel(x_[i], y_[i]);
    applyOne(i, gxQ88, gyQ88);
    integrate(i, dtMs);
    (void)resolveBlocking(x_[i], y_[i], vx_[i], vy_[i]);
    drawPixel(x_[i], y_[i]);
  }
}

void Experience_Sand::stepTeardown(uint32_t dtMs) {
  beginFrame();
  for (uint16_t i=0;i<MAX_PARTICLES;++i) if (live_[i]) {
    erasePixel(x_[i], y_[i]);
    applyOne(i, 0, -64);
    integrate(i, dtMs);
    if (y_[i] == 0) { live_[i]=0; --count_; }
    else { drawPixel(x_[i], y_[i]); }
  }
}

void Experience_Sand::applyOne(uint16_t i, int16_t axQ88, int16_t ayQ88) {
  vx_[i] += (int16_t)((axQ88 * GRAVITY_SCALE_Q88) >> 8);
  vy_[i] += (int16_t)((ayQ88 * GRAVITY_SCALE_Q88) >> 8);
  vx_[i] = (int16_t)((int32_t)vx_[i] * FRICTION_Q88 >> 8);
  vy_[i] = (int16_t)((int32_t)vy_[i] * FRICTION_Q88 >> 8);

  // Clamp velocity to avoid runaway
  if (vx_[i] > VEL_CAP_Q88)  vx_[i] = VEL_CAP_Q88;
  if (vx_[i] < -VEL_CAP_Q88) vx_[i] = -VEL_CAP_Q88;
  if (vy_[i] > VEL_CAP_Q88)  vy_[i] = VEL_CAP_Q88;
  if (vy_[i] < -VEL_CAP_Q88) vy_[i] = -VEL_CAP_Q88;

}

void Experience_Sand::integrate(uint16_t i, uint32_t dtMs) {
  int32_t dx = ((int32_t)vx_[i] * (int32_t)dtMs) >> 8;
  int32_t dy = ((int32_t)vy_[i] * (int32_t)dtMs) >> 8;
  int32_t nx = (int32_t)x_[i] + dx;
  int32_t ny = (int32_t)y_[i] + dy;

  if (nx < 0) { nx=0; vx_[i] = -vx_[i]/2; }
  if (ny < 0) { ny=0; vy_[i] = -vy_[i]/2; }
  if (nx > (W-1)) { nx=W-1; vx_[i] = -vx_[i]/2; }
  if (ny > (H-1)) { ny=H-1; vy_[i] = -vy_[i]/2; }

  x_[i] = (uint16_t)nx;
  y_[i] = (uint16_t)ny;
}

// ---- TOF ZONES ----
void Experience_Sand::updateZonesFromTOF() {
  int col = tof.getFingerPos();    // 0..7 (0/neg == none)
  float mm = tof.getFingerDist();  // distance in mm

  for (uint8_t z=0; z<zoneCount_; ++z) zones_[z].active = false;
  if (col <= 0 || mm <= 0) return;

  uint16_t sx = (uint16_t)((col + 0.5f) * (W / 8.0f));
  uint16_t sy = H/2;

  if (mm < TOF_MIN_MM) mm = TOF_MIN_MM;
  if (mm > TOF_MAX_MM) mm = TOF_MAX_MM;
  float t = (mm - TOF_MIN_MM) / float(TOF_MAX_MM - TOF_MIN_MM);
  uint8_t r = (uint8_t)(ZONE_R_MAX - t * (ZONE_R_MAX - ZONE_R_MIN));

  addOrUpdateZone(sx, sy, r);
}

void Experience_Sand::addOrUpdateZone(uint16_t sx, uint16_t sy, uint8_t r) {
  for (uint8_t z=0; z<zoneCount_; ++z) {
    int32_t dx = (int32_t)sx - (int32_t)zones_[z].cx;
    int32_t dy = (int32_t)sy - (int32_t)zones_[z].cy;
    uint32_t d2 = (uint32_t)(dx*dx + dy*dy);
    uint32_t th = (uint32_t)(zones_[z].r * zones_[z].r * 3 / 4);
    if (d2 <= th) {
      zones_[z].cx = sx; zones_[z].cy = sy;
      zones_[z].r  = r;
      zones_[z].active = true;
      zones_[z].createdMs = millis();
      return;
    }
  }

  if (zoneCount_ < MAX_ZONES) {
    zones_[zoneCount_] = {sx, sy, r, true, millis()};
    zoneCount_++;
  } else {
    uint8_t oldest = 0;
    unsigned long oldestMs = zones_[0].createdMs;
    for (uint8_t z=1; z<MAX_ZONES; ++z) {
      if (zones_[z].createdMs < oldestMs) { oldestMs = zones_[z].createdMs; oldest = z; }
    }
    zones_[oldest] = {sx, sy, r, true, millis()};
  }
}

void Experience_Sand::expireStaleZones(unsigned long now) {
  for (uint8_t z=0; z<zoneCount_; ++z) {
    if (zones_[z].active) continue;
  }
}

bool Experience_Sand::resolveBlocking(uint16_t &nx, uint16_t &ny, int16_t &vxQ, int16_t &vyQ) {
  bool hit = false;
  for (uint8_t z=0; z<zoneCount_; ++z) {
    Zone &Z = zones_[z];
    if (Z.r == 0) continue;
    int32_t dx = (int32_t)nx - (int32_t)Z.cx;
    int32_t dy = (int32_t)ny - (int32_t)Z.cy;
    int32_t d2 = dx*dx + dy*dy;
    int32_t r2 = (int32_t)Z.r * (int32_t)Z.r;
    if (d2 < r2) {
      hit = true;
      if (dx==0 && dy==0) { dx = 1; }
      float invLen = 1.0f / sqrtf((float)(dx*dx + dy*dy));
      float nxn = dx * invLen;
      float nyn = dy * invLen;
      nx = (uint16_t)(Z.cx + nxn * Z.r);
      ny = (uint16_t)(Z.cy + nyn * Z.r);
      float vx = vxQ / 256.0f;
      float vy = vyQ / 256.0f;
      float dot = vx*nxn + vy*nyn;
      vx -= dot * nxn;
      vy -= dot * nyn;
      vx *= 0.90f;
      vy *= 0.90f;
      vxQ = (int16_t)(vx * 256.0f);
      vyQ = (int16_t)(vy * 256.0f);
    }
  }
  return hit;
}

int Experience_Sand::findFree() {
  for (uint16_t i=0;i<MAX_PARTICLES;++i) if (!live_[i]) return (int)i;
  return -1;
}

void Experience_Sand::recycleOne() {
  for (uint16_t i=0;i<MAX_PARTICLES;++i) {
    if (live_[i] && y_[i] > (H - 12) && abs(vx_[i]) < 4 && abs(vy_[i]) < 4) {
      erasePixel(x_[i], y_[i]);
      live_[i]=0; --count_;
      return;
    }
  }
  for (uint8_t tries=0; tries<50; ++tries) {
    uint16_t i = random(0, MAX_PARTICLES);
    if (live_[i]) { erasePixel(x_[i], y_[i]); live_[i]=0; --count_; return; }
  }
}

